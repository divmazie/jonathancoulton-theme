{% macro pipeline_button(stage, copy, enable) %}
    <button name="pipeline_stage"
            value="{{ stage }}"
            {% if not enable %}
                disabled="disabled"
            {% endif %}
    >
        {{ copy }}
    </button>
{% endmacro %}

{% import _self as m %}


<html>
<head>
    <style>
        body {

            padding: 30px;
            background-color: lightgoldenrodyellow;
        }

        pre {
            background-color: lightsalmon;
            font-size: 130%;
            padding: 11px;
        }

        #pipeline ol {
            font-size: 120%;
        }

        li p {
            font-size: 80%;
            margin-top: 3px;
            margin-bottom: 7px;
        }

        li button {
            margin-bottom: 15px;
        }
    </style>
</head>

<body>
<form id="pipeline">

    {% if status %}
        <pre>{{ status }}</pre>
        {{ m.pipeline_button('status_x', 'Dismiss This Update', true) }}
    {% endif %}


    <h1>Pipeline Status</h1>
    <ol>
        <li>Song Encodes ({{ sync_man.pending_encodes|length }} pending of {{ sync_man.all_encodes|length }})

            <p>This is the first step in the process. Songs can only be pending once
                they and their parent albums are filled out.</p>

            <p> Once songs are submitted to be encoded they will start coming in. You don't need to resubmit them a
                bunch of times. You can refresh this page to check status.</p>

            {{ m.pipeline_button('encodes', "Submit Remaining Encodes for Processing", can_encode ) }}
        </li>
        <li>Album Zips ({{ sync_man.pending_zips|length }} pending of {{ sync_man.all_zips|length }})
            <p>Once all the songs are encoded we can zip up the albums.</p>

            {{ m.pipeline_button('zips', "Zip Up Albums", can_zip ) }}
        </li>
        <li>S3 Uploads
            ({{ sync_man.uploaded_assets|length }} uploaded,
            {{ sync_man.un_uploaded_assets|length }} waiting to upload
            ({{ sync_man.uploadable_assets|length }} total))
            <p>Once all tracks and albums are created, they need to be uploaded to s3</p>

            {{ m.pipeline_button('s3', "Upload all the stuff we got", can_upload ) }}

        </li>
        <li>Shopify Remote Cache
            <p>Shopify is SLOWWW to talk to, so we have to take precautions to say as little as possible.
                This pulls down the products and caches them locally so we can use that cache, rather than
                asking for it repeatedly.</p>

            {% if sync_man.remote_shopify_products_mtime %}
                <p style="background-color: lightgreen;">loaded shopify cache
                    [{{ sync_man.remote_shopify_products_filename }}],
                    mtime: {{ sync_man.remote_shopify_products_mtime }} </p>
            {% endif %}
            {{ m.pipeline_button('shopify_cache', "Huh, yes. Cache it (or refresh the cache)", true ) }}

        </li>
        <li>Shopify Product Sync
            ({{ sync_man.remote_shopify_products|length }} remote products
            ({{ sync_man.shopify_products_to_delete|length }} to delete),
            {{ sync_man.local_music_store_products|length }} local products
            ({{ sync_man.music_store_products_to_create|length }} to create,
            {{ sync_man.music_store_products_to_update|length }} to update,
            {{ sync_man.music_store_products_to_skip|length }} up to date))

            <p>Once everything is on s3, then we make sure our records with our store are all good.
                Shopify pretty much makes us wait 500 ms between each call we make. We make one call
                per product... so... you'll wait a bit.</p>

            {{ m.pipeline_button('shopify_create', "Create Products", sync_man.music_store_products_to_create) }}
            {{ m.pipeline_button('shopify_update', "Update Products", sync_man.music_store_products_to_update) }}

        </li>
        <li>Fetch remote cache
            <p>A service called Fetch actually handles fulfilling the digital downloads sold through
                shopify. We cache their list of everything to speed up the rest of our sync, which is the next
                step.</p>

            {% if sync_man.fetch_remote_products_mtime %}
                <p style="background-color: lightgreen;">loaded fetch cache
                    [{{ sync_man.fetch_remote_products_filename }}],
                    mtime: {{ sync_man.fetch_remote_products_mtime }} </p>
            {% endif %}

            {{ m.pipeline_button('fetch_cache', "Fetch the cache of fetch files and cache them in the fetch cache", true ) }}

        </li>
        <li>Fetch Product Sync
            ({{ sync_man.fetch_remote_products|length }} remote products
            ({{ sync_man.remote_fetch_delete_products|length }} to delete),
            {{ sync_man.uploadable_assets|length }} local products
            ({{ sync_man.local_fetch_create_products|length }} to create,
            {{ sync_man.local_fetch_update_products|length }} to update)

            <p>You must be getting tired of reading this. Fetch takes all the individual digital assets and ties
            them to the shopify SKU (multiple SKUs per product representing encode types), and links
            fetch to the s3 assets we uploaded earlier.</p>


        </li>

        <li>Garbage Collection ({{ sync_man.garbage_attachments|length }} items)
            <p>If your store all is nice and updated, why leave files from a previous iteration around?
                They're big and unseemly and useless. Wait til everything is updated to delete them, though.
                Till then, parts of the site may still use them.</p>

            {{ m.pipeline_button('garbage', "Take Out The Trash Baby!", garbage_attachments ) }}

        </li>
    </ol>
</form>
<p></p>


<h1>Albums ({{ sync_man.all_albums|length }} total)</h1>

<p>Albums are displayed, sorted by their sort key (which is in parentheses after the name). If two
    albums sort keys are identical, they may display in a different order in the store. </p>

<p>The number in parentheses is the track number in the backend. The other number is
    simply a result of it being an HTML list.</p>

<p style="margin-left:15px;">
    <strong style="color:green">green</strong> stuff is done <br/>
    <strong style="color:red">red</strong> stuff is pending<br/>
</p>


<ol>
    {% for album in sync_man.all_albums if album.isFilledOut %}
        <li>
            <span style="color:{{ album.isFilledOut?'green':'red' }}">{{ album.title }}</span>
            ({{ album.numTracks }} tracks)
            <a href="{{ album.edit_link }}">EDIT</a><br/>

            <div style="font-size: 80%">
                <span>Zip Status:
                    {% for zipconf in album.albumZipConfigs %}
                        <span style="color:{{ zipconf.assetExists?'green':'red' }}">{{ zipconf.configName }}</span>&nbsp;
                    {% endfor %}
                </span><br/>
                <span>S3 Status:
                    {% for zipconf in album.albumZipConfigs %}
                        <span style="color:{{ zipconf.asset.isUploadedToS3?'green':'red' }}">{{ zipconf.configName }}</span>&nbsp;
                    {% endfor %}
                </span>
            </div>
        </li>

        <ol>
            {% for track in album.albumTracks %}

                <li>
                    <span style="color:{{ track.isFilledOut?'green':'red' }}">
                    ({{ track.trackNumber }}) {{ track.title }}</span>
                    <a href="{{ track.edit_link }}">edit</a>

                    <div style="font-size: 80%">
                        <span>Encode Status:
                            {% for encodeConf in track.getTrackEncodeConfigs %}
                                <span style="color:{{ encodeConf.assetExists?'green':'red' }}">{{ encodeConf.configName }}</span>&nbsp;
                            {% endfor %}
                        </span><br/>
                        <span>S3 Status:
                            {% for encodeConf in track.getTrackEncodeConfigs %}
                                <span style="color:{{ encodeConf.asset.isUploadedToS3?'green':'red' }}">{{ encodeConf.configName }}</span>&nbsp;
                            {% endfor %}
                        </span>

                    </div>

                </li>
            {% endfor %}
        </ol>
    {% endfor %}
</ol>


</body>

</html>